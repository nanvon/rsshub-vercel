import{t as e}from"./config-D7dgKYF5.mjs";import{t}from"./logger-CkUWGGaS.mjs";import{LRUCache as n}from"lru-cache";import r from"ioredis";const i={available:!1},a={};var o={init:()=>{a.memoryCache=new n({ttl:e.cache.routeExpire*1e3,max:e.memory.max}),i.available=!0},get:(e,t=!0)=>{if(e&&i.available&&a.memoryCache){let n=a.memoryCache.get(e,{updateAgeOnGet:t});return n&&(n+=``),n}else return null},set:(t,n,r=e.cache.contentExpire)=>{if((!n||n===`undefined`)&&(n=``),typeof n==`object`&&(n=JSON.stringify(n)),t&&i.available&&a.memoryCache)return a.memoryCache.set(t,n,{ttl:r*1e3})},clients:a,status:i};const s={available:!1},c={},l=e=>{if(e.startsWith(`rsshub:cacheTtl:`))throw Error(`"rsshub:cacheTtl:" prefix is reserved for the internal usage, please change your cache key`);return`rsshub:cacheTtl:${e}`};var u={init:()=>{c.redisClient=new r(e.redis.url),c.redisClient.on(`error`,e=>{s.available=!1,t.error(`Redis error: `,e)}),c.redisClient.on(`end`,()=>{s.available=!1}),c.redisClient.on(`connect`,()=>{s.available=!0,t.info(`Redis connected.`)})},get:async(t,n=!0)=>{if(t&&s.available&&c.redisClient){let r=l(t),[i,a]=await c.redisClient.mget(t,r);return i&&n&&(a?c.redisClient.expire(r,a):a=e.cache.contentExpire+``,c.redisClient.expire(t,a),i+=``),i||``}else return null},set:(t,n,r=e.cache.contentExpire)=>{if(!(!s.available||!c.redisClient)&&((!n||n===`undefined`)&&(n=``),typeof n==`object`&&(n=JSON.stringify(n)),t))return r!==e.cache.contentExpire&&c.redisClient.set(l(t),r,`EX`,r),c.redisClient.set(t,n,`EX`,r)},clients:c,status:s};const d={get:()=>null,set:()=>null};let f;if(e.cache.type===`redis`){f=u,f.init();let{redisClient:e}=f.clients;d.get=async t=>{if(t&&f.status.available&&e)return await e.get(t)},d.set=f.set}else if(e.cache.type===`memory`){f=o,f.init();let{memoryCache:t}=f.clients;d.get=e=>{if(e&&f.status.available&&t)return t.get(e,{updateAgeOnGet:!1})},d.set=(n,r,i=e.cache.routeExpire)=>{if((!r||r===`undefined`)&&(r=``),typeof r==`object`&&(r=JSON.stringify(r)),n&&t)return t.set(n,r,{ttl:i*1e3})}}else f={init:()=>null,get:()=>null,set:()=>null,status:{available:!1},clients:{}},t.error(`Cache not available, concurrent requests are not limited. This could lead to bad behavior.`);var p={...f,tryGet:async(t,n,r=e.cache.contentExpire,i=!0)=>{if(typeof t!=`string`)throw TypeError(`Cache key must be a string`);let a=await f.get(t,i);if(a){let e;try{e=JSON.parse(a)}catch{e=null}return e&&(a=e),a}else{let e=await n();return f.set(t,e,r),e}},globalCache:d};export{p as t};